//
// Copyright 2016 New Zealand Institute of Language, Brain and Behaviour, 
// University of Canterbury
// Written by Robert Fromont - robert.fromont@canterbury.ac.nz
//
//    This file is part of nzilbb.ag.
//
//    nzilbb.ag is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 3 of the License, or
//    (at your option) any later version.
//
//    nzilbb.ag is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with nzilbb.ag; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
package nzilbb.transcriber;

import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import java.io.InputStream;
import java.io.IOException;
import java.io.Writer;
import java.io.ByteArrayOutputStream;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.CharArrayReader;
import java.util.Vector;
import java.util.Properties;
import java.util.HashMap;
import java.util.Enumeration;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import org.xml.sax.InputSource;

/**
 * Transcriber transcript - a representation of the internal structure of the XML document, including speakers, topics, sections, turns, etc.
 * @author Robert Fromont
 */

public class Transcript 
{
   // Attributes:
   
   /**
    * Database ID for the transcript
    */
   private String sId;
   /**
    * Id accessor - Database ID for the transcript
    * @return Database ID for the transcript
    */
   public String getId() { return sId; }
   /**
    * Id mutator - Database ID for the transcript
    * @param sNewId Database ID for the transcript
    */
   public void setId(String sNewId) { sId = sNewId; }
   
   /**
    * Name of the person who typed the transcript
    */
   private String sScribe;
   /**
    * Scribe accessor - Name of the person who typed the transcript
    * @return Name of the person who typed the transcript
    */
   public String getScribe() { return sScribe; }
   /**
    * Scribe mutator - Name of the person who typed the transcript
    * @param sNewScribe Name of the person who typed the transcript
    */
   public void setScribe(String sNewScribe) { sScribe = sNewScribe; }
   
   /**
    * Name of the WAV (or other media) file to which the transcript corresponds
    */
   private String sAudioFilename;
   /**
    * AudioFilename accessor - Name of the WAV (or other media) file to which the transcript corresponds
    * @return Name of the WAV (or other media) file to which the transcript corresponds
    */
   public String getAudioFilename() { return sAudioFilename; }
   /**
    * AudioFilename mutator - Name of the WAV (or other media) file to which the transcript corresponds
    * @param sNewAudioFilename Name of the WAV (or other media) file to which the transcript corresponds
    */
   public void setAudioFilename(String sNewAudioFilename) { sAudioFilename = sNewAudioFilename; }
   
   /**
    * The version number of the transcript, as generated by Transcriber
    */
   private String sVersion;
   /**
    * Version accessor - The version number of the transcript, as generated by Transcriber
    * @return The version number of the transcript, as generated by Transcriber
    */
   public String getVersion() { return sVersion; }
   /**
    * Version mutator - The version number of the transcript, as generated by Transcriber
    * @param sNewVersion The version number of the transcript, as generated by Transcriber
    */
   public void setVersion(String sNewVersion) { sVersion = sNewVersion; }
   
   /**
    * The date of this version of the transcript, as generated by Transcriber
    */
   private String sVersionDate;
   /**
    * VersionDate accessor - The date of this version of the transcript, as generated by Transcriber
    * @return The date of this version of the transcript, as generated by Transcriber
    */
   public String getVersionDate() { return sVersionDate; }
   /**
    * VersionDate mutator - The date of this version of the transcript, as generated by Transcriber
    * @param sNewVersionDate The date of this version of the transcript, as generated by Transcriber
    */
   public void setVersionDate(String sNewVersionDate) { sVersionDate = sNewVersionDate; }
   
   /**
    * Language of the transcript
    */
   private String sLanguage;
   /**
    * Language accessor - Language of the transcript
    * @return Language of the transcript
    */
   public String getLanguage() { return sLanguage; }
   /**
    * Language mutator - Language of the transcript
    * @param sNewLanguage Language of the transcript
    */
   public void setLanguage(String sNewLanguage) { sLanguage = sNewLanguage; }
   
   /**
    * 'Program' that the recording is of
    */
   private String sProgram = "";
   /**
    * Program accessor 
    * @return 'Program' that the recording is of
    */
   public String getProgram() { return sProgram; }
   /**
    * Program mutator
    * @param sNewProgram 'Program' that the recording is of
    */
   public void setProgram(String sNewProgram) { sProgram = sNewProgram; }
   
   /**
    * Recording date
    */
   private String sAirDate = "";
   /**
    * AirDate accessor 
    * @return Recording date
    */
   public String getAirDate() { return sAirDate; }
   /**
    * AirDate mutator
    * @param sNewAirDate Recording date
    */
   public void setAirDate(String sNewAirDate) { sAirDate = sNewAirDate; }
   
   /**
    * The format of the media - e.g. wav, mp3, mpg, avi...
    */
   private String sMediaFormat = "";
   /**
    * MediaFormat accessor 
    * @return The format of the media - e.g. wav, mp3, mpg, avi...
    */
   public String getMediaFormat() { return sMediaFormat; }
   /**
    * MediaFormat mutator
    * @param sNewMediaFormat The format of the media - e.g. wav, mp3, mpg, avi...
    */
   public void setMediaFormat(String sNewMediaFormat) { sMediaFormat = sNewMediaFormat; }
   
   /**
    * Speakers that appear in the transcript - a Vector of {@link nz.ac.canterbury.ling.transcriber.TranscriptSpeaker} objects
    */
   private Vector<Speaker> vSpeakers = new Vector<Speaker>();
   /**
    * Speakers accessor - Speakers that appear in the transcript - a Vector of Speaker objects
    * @return Speakers that appear in the transcript - a Vector of Speaker objects
    */
   public Vector<Speaker> getSpeakers() { return vSpeakers; }
   /**
    * Speakers mutator - Speakers that appear in the transcript - a Vector of Speaker objects
    * @param vNewSpeakers Speakers that appear in the transcript - a Vector of Speaker objects
    */
   public void setSpeakers(Vector<Speaker> vNewSpeakers) { vSpeakers = vNewSpeakers; }
   
   /**
    * Topics that appear in the transcript - key=topic_id, value=desc
    */
   private Properties pTopics = new Properties();
   /**
    * Topics accessor - Topics that appear in the transcript - key=topic_id, value=desc
    * @return Topics that appear in the transcript - key=topic_id, value=desc
    */
   public Properties getTopics() { return pTopics; }
   /**
    * Topics mutator - Topics that appear in the transcript - key=topic_id, value=desc
    * @param pNewTopics Topics that appear in the transcript - key=topic_id, value=desc
    */
   public void setTopics(Properties pNewTopics) { pTopics = pNewTopics; }
   
   /**
    * Sections of this transcript (A list of {@link nz.ac.canterbury.ling.transcriber.Section} objects).
    */
   protected Vector<Section> vSections = new Vector<Section>();
   /**
    * Sections accessor
    * @return Sections of this transcript (A list of {@link nz.ac.canterbury.ling.transcriber.Section} objects)
    */
   public Vector<Section> getSections() { return vSections; }
   /**
    * Sections mutator
    * @param vNewSections Sections of this transcript (A list of {@link nz.ac.canterbury.ling.transcriber.Section} objects)
    */
   public void setSections(Vector<Section> vNewSections) { if (vNewSections != null) vSections = vNewSections; }
   
   /**
    * Provides an ordered list of turns across all sections in the transcript.
    * @return A Vector of Turn objects (A list of {@link nz.ac.canterbury.ling.transcriber.Turn} objects)
    */
   public Vector<Turn> getTurns()
   {
      Vector<Turn> vTurns = new Vector<Turn>();
      Enumeration<Section> enSections = getSections().elements();
      while (enSections.hasMoreElements())
      {
	 Section section = enSections.nextElement();
	 vTurns.addAll(section.getTurns());
      }
      return vTurns;
   } // end of getTurns
   
   /**
    * Speakers that appear in the transcript - a Hashtable of {@link nz.ac.canterbury.ling.transcriber.Speaker} objects keyed on SpeakerId
    */
   private HashMap<String,Speaker> htSpeakers = new HashMap<String,Speaker>();
   
   /**
    * Constructor
    */
   public Transcript()
   {
   } // end of constructor
   
   /**
    * Resets the state of the object.
    */
   public void reset()
   {
      sId = null;
      sScribe = null;
      sAudioFilename = null;
      sVersion = null;
      sVersionDate = null;
      sLanguage = null;
      sProgram = "";
      sAirDate = "";
      sMediaFormat = "";
      vSpeakers = new Vector<Speaker>();
      pTopics = new Properties();
      htSpeakers = new HashMap<String,Speaker>();
      vSections = new Vector<Section>();
   } // end of reset()

   /**
    * Loads the transcript from a stream.
    * @param in
    * @throws IOException
    */
   public void load(InputStream in)
      throws IOException, ParserConfigurationException, SAXException
   {
      // convert from ISO-8859-1 to UTF-8
      ByteArrayOutputStream oBytes = new ByteArrayOutputStream();
      byte[] aBytes = new byte[1024];
      int iBytesRead = in.read(aBytes);
      while (iBytesRead >= 0)
      {
	 oBytes.write(aBytes, 0, iBytesRead);
	 iBytesRead = in.read(aBytes);
      } // next chunk	
      in.close();
      Charset latin1 = Charset.forName("ISO-8859-1");
      ByteBuffer bytes = ByteBuffer.wrap(oBytes.toByteArray());
      CharBuffer utf8 = latin1.decode(bytes);
      
      // read stream into a string, stripping out DTD reference so that
      // no attempt is made to resolve it
      StringBuffer strFile = new StringBuffer(utf8.length());
      BufferedReader reader = new BufferedReader(new CharArrayReader(utf8.array()));
      String sLine = reader.readLine();
      while (sLine != null)
      {
	 if (!sLine.startsWith("<!DOCTYPE Trans")) strFile.append(sLine);
	 sLine = reader.readLine();
      } // next line
      
      // Document factory
      DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
      DocumentBuilder builder = builderFactory.newDocumentBuilder();   
      
      // now read from the string
      StringReader sbis = new StringReader(strFile.toString());
      
      // parse
      Document document = builder.parse(new InputSource(sbis));
      
      build(document);
   } // end of load()
   
   /**
    * Parses the given XML file.
    * @param transcriptionXml The XML document to parse
    */
   public void build(Document transcriptionXml)
   {
      // get main attributes
      NodeList transcriptions = transcriptionXml.getElementsByTagName("Trans");
      Node transNode = transcriptions.item(0);
      
      setScribe(transNode.getAttributes().getNamedItem("scribe").getNodeValue());
      setAudioFilename(transNode.getAttributes().getNamedItem("audio_filename").getNodeValue());
      setVersion(transNode.getAttributes().getNamedItem("version").getNodeValue());
      setVersionDate(transNode.getAttributes().getNamedItem("version_date").getNodeValue());
      
      try
      {
	 setLanguage(transNode.getAttributes().getNamedItem("xml:lang").getNodeValue());
      }
      catch(Exception ex) {}
      
      // episode attributes
      NodeList episodes = transcriptionXml.getElementsByTagName("Episode");
      Node episodeNode = episodes.item(0);
      try
      {
	 setProgram(episodeNode.getAttributes().getNamedItem("program").getNodeValue());
      }
      catch(Exception ex) {}
      try
      {
	 setAirDate(episodeNode.getAttributes().getNamedItem("air_date").getNodeValue());
      }
      catch(Exception ex) {}
      
      // Speakers
      NodeList speakersList = transcriptionXml.getElementsByTagName("Speaker");
      for (int i = 0; i < speakersList.getLength(); i++)
      {
	 Node speakerNode = speakersList.item(i);
	 Speaker speaker = new Speaker(this, speakerNode);
	 addSpeaker(speaker);
      } // next speaker
      
      // Topics
      NodeList topicsList = transcriptionXml.getElementsByTagName("Topic");
      for (int i = 0; i < topicsList.getLength(); i++)
      {
	 Node topicNode = topicsList.item(i);
	 String sId = null;
	 String sDesc = null;
	 try
	 {
	    sId = topicNode.getAttributes().getNamedItem("id").getNodeValue();
	    try
	    {
	       sDesc = topicNode.getAttributes().getNamedItem("desc").getNodeValue();
	    }
	    catch(Exception exception) 
	    {
	       sDesc = sId;
	    }
	    
	    addTopic(sId, sDesc);
	 } 
	 catch (Exception exception) {}
	 
      } // next topic
      
      // Sections
      NodeList sectionsList = transcriptionXml.getElementsByTagName("Section");
      for (int i = 0; i < sectionsList.getLength(); i++)
      {
	 Node sectionNode = sectionsList.item(i);
	 Section section = new Section(this, sectionNode);
	 vSections.addElement(section);
      } // next section
      
   } // end of parse()
   
   /**
    * Adds a speaker to the speaker list.
    * @param speaker The speaker to add
    */
   public void addSpeaker(Speaker speaker)
   {
      vSpeakers.add(speaker);
      htSpeakers.put(speaker.getId(), speaker);
   } // end of addSpeaker()
   
   /**
    * Retrieve a speaker given a SpeakerId
    * @param sSpeakerId
    * @return The speaker, or null if the SpeakerId isn't present
    */
   public Speaker getSpeaker(String sSpeakerId)
   {
      if (htSpeakers.containsKey(sSpeakerId))
      {
	 return htSpeakers.get(sSpeakerId);
      }
      else
      {
	 return null;
      }
   } // end of getSpeaker()
   
   /**
    * Adds a topic to the topic list.
    * @param sTopicId
    * @param sDescription
    */
   public void addTopic(String sTopicId, String sDescription)
   {
      pTopics.setProperty(sTopicId, sDescription);
   } // end of addTopic()
   
   /**
    * Adds a turn to the end of the transcript.
    * @param theTurn
    */
   public void addTurn(Turn theTurn)
   {
      if (vSections.size() == 0)
      {
	 vSections.addElement(new Section(this));
      }
      vSections.lastElement().addTurn(theTurn);
   } // end of addTurn()
   
   /**
    * Adds a section to the end of the transcript.
    * @param theSection
    */
   public void addSection(Section theSection)
   {
      vSections.add(theSection);
   } // end of addTurn()
   
   /**
    * Access all words in the transcript.
    * @return A collection of all {@link nz.ac.canterbury.ling.transcriber.Word} objects in the transcript, in order.  They are returned in the order determined by {@link nz.ac.canterbury.ling.transcriber.Sync#getWords()} (so in the case of simultaneous speech, the words are sequentially but grouped by speaker).
    */
   public Vector<Word> getWords()
   {
      // gather up all the words into one collection
      Vector<Word> vWords = new Vector<Word>();
      
      // for each turn
      for (Turn turn : getTurns())
      {
	 // for each utterance
	 for (Sync sync : turn.getSyncs())
	 {
	    // add all words to our collection
	    vWords.addAll(sync.getWords());
	 } // next sync
      } // next turn
      return vWords;
   } // end of getWords()
   
   /**
    * Text-file representation of the object.
    * @param writer A Writer object to which the transcript should be written
    * @throws java.io.IOException
    */
   @SuppressWarnings("rawtypes")
   public void writeText(Writer writer)
      throws java.io.IOException
   {
      // XML header
      writer.write( 
	 "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
	 + "\n<!DOCTYPE Trans SYSTEM \"trans-14.dtd\">"
	 + "\n<Trans scribe=\"" + Transcript.xmlEscaped(getScribe()) + "\" "
	 + "audio_filename=\"" + Transcript.xmlEscaped(getAudioFilename()) + "\" "
	 + "version=\"" + Transcript.xmlEscaped(getVersion()) + "\" "
	 + "version_date=\"" + Transcript.xmlEscaped(getVersionDate()) + "\" "
	 + "xml:lang=\"" + Transcript.xmlEscaped(getLanguage()) + "\">"); 
      
      // topics
      if (getTopics().size() > 0)
      {
	 writer.write("\n<Topics>");
	 Enumeration enTopicIds = getTopics().propertyNames();
	 while (enTopicIds.hasMoreElements())
	 {
	    String sTopicId = (String)enTopicIds.nextElement();
	    String sTopicDesc = getTopics().getProperty(sTopicId);
	    writer.write(
	       "\n<Topic id=\"" + Transcript.xmlEscaped(sTopicId)
	       + "\" desc=\"" + Transcript.xmlEscaped(sTopicDesc)
	       + "\"/>");
	 } // next topic
	 writer.write(
	    "\n</Topics>");
      } // topics
      
      // speakers
      writer.write("\n<Speakers>");
      for  (Speaker speaker : getSpeakers())
      {
	 speaker.writeText(writer);
      } // next speaker
      writer.write("\n</Speakers>");
      
      // episode
      writer.write("\n<Episode");
      if (getProgram() != null && getProgram().length() > 0)
      {
	 writer.write(" program=\"" + Transcript.xmlEscaped(getProgram())
		      + "\"");
      }
      if (getAirDate() != null && getAirDate().length() > 0)
      {
	 writer.write(" air_date=\"" + Transcript.xmlEscaped(getAirDate())
		      + "\"");
      }
      writer.write(">");
      
      // sections
      Enumeration<Section> enSections = getSections().elements();
      while (enSections.hasMoreElements())
      {
	 Section section = enSections.nextElement();
	 section.writeText(writer);
      } // next speaker
      
      // close tags
      writer.write("\n</Episode>");
      writer.write("\n</Trans>");
      
   } // writeText
   
   /**
    * String represenation.
    * @return The object as a String
    */
   public String toString()
   {
      String str = getId();
      str += "\nscribe: " + getScribe(); 
      str += "\naudio_filename: " + getAudioFilename(); 
      str += "\nversion: " + getVersion(); 
      str += "\nversion_date: " + getVersionDate(); 
      return str;
   } // end of toString()
   
   /**
    * Escapes xml-sensitive characters like &amp; &lt; and &gt;.
    * @param sRaw
    * @return the input string with XML characters escaped
    */
   public static String xmlEscaped(String sRaw)
   {
      if (sRaw == null)
      {
	 return "";
      }
      else
      {
	 return sRaw
	    .replaceAll("&", "&amp;")
	    .replaceAll(">", "&gt;")
	    .replaceAll("<", "&lt;")
	    .replaceAll("\"", "&quot;");
      }
   } // end of xmlEscaped()
   
   /**
    * Formats a double as a Transcriber-readable time string.
    * @param dSeconds
    * @return the time as a string
    */
   public static String getTimeString(double dSeconds)
   {
      // round to 3 decimal places
      int iMilliseconds = (int)(dSeconds * 1000);
      dSeconds = (double)iMilliseconds / 1000;
      return "" + dSeconds;
   } // end of getTimeString()
   
   /**
    * The version number of the transcript, as generated by Transcriber, as an int
    * @return The version number of the transcript, as generated by Transcriber
    */
   public int getVersionAsInt() 
   { 
      try
      {
	 return Integer.parseInt(sVersion); 
      }
      catch (Exception x)
      {
	 return 0;
      }
   }
   
   /**
    * Check the structure of the transcript is valid. For example, there must be no simultaneous-speech turns where both speakers are actually the same speaker.
    * @return Vector of String objects, each being an error message, or null if there are no errors.
    */
   public Vector<String> validationErrors()
   {
      Vector<String> vErrors = new Vector<String>();
      // check for simultaneous speech turns where the speakers are the same

      for (Section section : getSections()) {
         Turn lastTurn = null;
         // for each turn
         for (Turn turn : section.getTurns())
         {
            // for each sync
            Enumeration<Sync> syncsEnum = turn.getSyncs().elements();
            while(syncsEnum.hasMoreElements())
            {
               Sync sync = syncsEnum.nextElement();	       
               if (sync.isSimultaneousSpeech())
               {
                  // whole bunch of syncs at once
                  Vector<String> vSpeakers = new Vector<String>();
                  Enumeration<SimultaneousSync> enSimultaneousSyncs 
                     = sync.getSimultaneousSyncs().elements();
                  while (enSimultaneousSyncs.hasMoreElements())
                  {
                     SimultaneousSync sim = enSimultaneousSyncs.nextElement();
                     if (vSpeakers.contains(sim.getWho()))
                     {
                        vErrors.add(
                           "Simultaneous speech at " + sync.getTime()
                           +"s contains the same speaker more than once.");
                     }
                     else
                     {
                        vSpeakers.add(sim.getWho());
                     }
                  } // next sync
               } // simultaneous speech
            } // next sync
            
            // Check the turn start is the same as the last end.
            if (lastTurn != null)
            {
               if (!lastTurn.getEndTime().equals(turn.getStartTime()))
               {
                  // choose the earlier of the two times for the boundary
                  if (lastTurn.getEndTimeAsDouble() < turn.getStartTimeAsDouble())
                  {
                     vErrors.add(
                        "Turn's end " + lastTurn.getEndTime()
                        +" before next turn start " + turn.getStartTime()
                        +": using " + lastTurn.getEndTime());
                     turn.setStartTime(lastTurn.getEndTime());
                     
                     // need to change the first Sync too
                     if (turn.getSyncs().size() > 0)
                     {
                        turn.getSyncs().firstElement()
                           .setTime(lastTurn.getEndTime());
                     }
                  }
                  else
                  {
                     vErrors.add(
                        "Turn's end " + lastTurn.getEndTime()
                        +" after next turn start " + turn.getStartTime()
                        +": using " + turn.getStartTime());
                     lastTurn.setEndTime(turn.getStartTime());
                     
                     // need to change the last Sync too
                     if (lastTurn.getSyncs().size() > 0)
                     {
                        lastTurn.getSyncs().lastElement()
                           .setEndTime(turn.getStartTime());
                     }
                  }               
               } // boundary inconsistency
            } // lastTurn is set
            
            lastTurn = turn;
         } // next turn
      } // next section
      
      if (vErrors.size() > 0)
      {
	 return vErrors;
      }
      else
      {
	 return null;
      }
   } // end of validationErrors()

   
   
} // end of class Transcript
