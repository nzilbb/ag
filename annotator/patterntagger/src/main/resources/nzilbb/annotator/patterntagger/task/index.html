<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Pattern Tagger</title>
    <link rel="stylesheet" href="index.css" type="text/css">
    <script src="util.js" type="text/javascript"></script>
  </head>
  <body>
    <details><summary> The Pattern Tagger can generate new annotations by applying regular
        expressions to annotations on a selected layer. </summary>
      
      <details><summary><b> Source Layer </b></summary>
        
        <p> The <i> Source Layer </i> setting determines which layer will be used to find
          matches for the regular expressions.  Annotations on the selected layer will be
          checked against each regular expression. </p>
      
      </details>
      <details><summary><b> Destination Layer </b></summary>
        <p> This is the layer that new annotations will be added to. You can pick an
          existing layer, or add a new layer: </p>
        <dl>
          <dt> [add new word layer] </dt>
          <dd> Use this option if your <b> Source Layer </b> is a word layer and your mappings
            define tags for individual word tokens. </dd>
          
          <dt> [add new phrase layer] </dt>
          <dd> Use this option if your tags could span multiple word tokens, but will
            always be within the same speaker turn. </dd>
          
          <dt> [add new span layer] </dt>
          <dd> Use this option if your tags could span multiple word tokens, and could
            span words from different speaker-turns. </dd>
          
        </dl>
      </details>
      <details><summary><b> Language </b></summary>
        
        <p> The <i>Language</i> setting determines which language to target for
          annotation. Leave this blank to ignore language, or enter an ISO language/locale code,
          e.g. <tt> en-NZ </tt>, to target varieties of a particular language. This setting is
          treated as a regular expression, so <tt> es.*</tt> will target all varietys of
          Spanish, etc. </p>  
        
        <p>If you specify a language, then only utterances in the language specified will be
          annotated. There are three factors that determine the language of an utterance:</p> 
        <ol>
          <li> The text may be language-tagged - i.e. be enclosed by an annotation on
            the layer selected for <b> Phrase Language Layer </b>. </li> 
          <li> If not, the layer selected for <b> Transcript Language Attribute </b> is
            used to determine the language.</li>  
          <li> If the transcript has no language otherwise explicitly specified, then the
            language of the corpus is assumed.</li> 
        </ol>
        
        <p> <b>NB</b> The language setting only applies if the <b> Desination Layer </b>
          is word or segment layer, not for phrase/span layer annotation. </p>
        
      </details>
      <details><summary><b> Mappings </b></summary>
      
      <p> The main area of the configuration form is a list of regular expressions to match
        against, which starts of empty. </p>
      
      <p> To add a pattern, click the + button on the right hand side. </p>
      
      <p> To remove a pattern, select it in the list and click the - button on the right
        hand side. </p>
      
      <p> The patterns are checked in the order you specify.  You can move a pattern up or
        down in the order by selecting it and using the <big>&uarr;</big>
        and <big>&darr;</big> buttons on the right. </p>
      
      <details><summary> Regular expression to match </summary>

        <p> This column contains the regular expression that will be applied to the source
          layer annotations. </p>
        
        <p> If both your source and destination layers are word layers, these patterns will be
          applied to each word individually. </p>
        <p> If your source layer is a word layer and your destination layer is a phrase layer,
          these patterns will be applied to the words concatenated together with intervening
          spaces, one speaker-turn at a time. </p>
        <p> If your source layer is a word layer and your destination layer is a span
          layer, these patterns will be applied to the words concatenated together with
          intervening spaces, across the whole transcript. </p>
        
        <p> You can use capturing groups in your regular expressions, to copy parts of the
          matching annotation to the target layer. </p>
        
        <p> More details about regular expression syntax are given in
          the <a href="#regex">Regular expression help</a> below. </p>
        
      </details>
      
      <details><summary> Representation to store when matched </summary>
        
        <p> This column specifies what to do if the regular expression is matched. There are
          several possible options: </p>
        <ul>
          <li> If the cell is left blank, then matching stops and no annotation is saved in
            the target layer.  This can be used to 'filter out' words on the source layer. </li>
          <li> If the cell is filled in with ordinary text, an annotation will be created with
            that text. </li>
          <li>If the cell includes captured groups (i.e. like <code>$1</code>, <code>$2</code>, etc.),
            then the captured contents from the source layer annotation are substituted in. 
	    <br> e.g. if the regular expression is <code>(.).*ing</code> (where the
	    parenthesis capture the first character of words ending in "...ing"), and the
	    Representation to store is set to <q>$1...IN</q>,  
	    then the $1 will be substituted for the first character of the matched word 
	    <br>- i.e. <q>eating</q> → <q>e...IN</q>, <q>thing</q> → <q>t...IN</q>,
            <q>sing</q> → <q>s...IN</q>, etc.</li>
          <li> If you click the down-arrow that appears when editing the cell, and select a
            layer of the list, then the annotation from the selected layer will be copied into
            the target layer. This option is only available if your target layer is a word
            layer.</li> 
        </ul>
      </details>
      </details>
      <details><summary><b> Non-matches </b></summary>
        
        <p> If the annotation on the source layer does not match any regular expression in the
          list, there are two options: </p>
        <ul>
          <li><i> deleted in the target layer </i> - any existing annotation on the target
            layer will be deleted.</li> 
          <li><i> ignored in the target layer </i> - any existing annotation on the target
            layer will be left in place.  This option is useful when the Pattern Tagger is used
            as an auxiliary layer manager, and another layer manager may have already annotated
            words.</li> 
        </ul>

      </details>
      <details><summary><b> Some examples </b></summary>

        <p> For example, you might want to identify filled pauses that might be variously
          transcribed as <q>um</q>, <q>ummm</q>, <q>ahm</q>, <q>ah</q>, <q>aah</q>, <q>er</q>,
          <q>erm</q>, etc...</p>  

        <p>To do this, you would configure an annotator task with the following regular
          expressions applied to the <i> orthography </i> layer to create new annotations on
          a new <i> filled pauses </i> word-tag layer: </p>
        
        <table style="margin: auto;">
          <tr><th> Regular Expression </th> <td> </td> <th> Label </th></tr>        
          <tr><td><code> [ua]+h*m+ </code></td><td>→</td><td> um </td></tr>
          <tr><td><code> e+r*m+    </code></td><td>→</td><td> um </td></tr>
          <tr><td><code> a+h+      </code></td><td>→</td><td> ah </td></tr>
          <tr><td><code> e+r+      </code></td><td>→</td><td> er </td></tr>
        </table>
        
        <p> The result would be that every instance of words like <q>um</q>, <q>ummm</q>,
          <q>ahm</q>, <q>ah</q>, <q>aah</q>, <q>er</q>, <q>erm</q>, etc... would be tagged
          with either <q>um</q> or <q>ah</q> or <q>er</q>. </p> 
        
        <p> Or you might want to tag combinations of words.  For example, you might want to
          identify all instances of the expression <q>kind of thing</q>. </p>  
        
        <p>To do this, you would, you would configure an annotator task with the following regular
          expressions applied to the <i> orthography </i> layer to create new annotations on
          a new <i> ellipsis </i> phrase layer: </p>
        <table style="margin: auto;">
          <tr><th> Regular Expression </th> <td> </td> <th> Label </th></tr>        
          <tr><td><code> kind(a|( of)) thing</code></td><td>→</td><td> ... </td></tr>
        </table>
        
        <p> The result would be that every instance the sequence of words <q>kind of thing</q> or
          <q>kinda thing</q> would be tagged with <q>...</q>. </p>
        
      </details>
      <details><summary><b><a name="regex">Regular expression help</a></b></summary>

        <p><i>The following is take from the Java regular expression documentation:</i></p>
        
        <a name="sum">
          <h4> Summary of regular-expression constructs </h4>
        </a>
        
        <table border="0" cellpadding="1" cellspacing="0" 
               summary="Regular expression constructs, and what they match">
          
          <tr align="left">
            <th bgcolor="#CCCCFF" align="left" id="construct">Construct</th>
            <th bgcolor="#CCCCFF" align="left" id="matches">Matches</th>
          </tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="characters">Characters</th></tr>
          
          <tr><td valign="top" headers="construct characters"><i>x</i></td>
            <td headers="matches">The character <i>x</i></td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\\</tt></td>
            <td headers="matches">The backslash character</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td>
            <td headers="matches">The character with octal value <tt>0</tt><i>n</i>
              (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td>
            <td headers="matches">The character with octal value <tt>0</tt><i>nn</i>
              (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td>
            <td headers="matches">The character with octal value <tt>0</tt><i>mnn</i>
              (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3,
              0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td>
            <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hh</i></td></tr>
          <tr><td valign="top" headers="construct characters"><tt>&#92;u</tt><i>hhhh</i></td>
            <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hhhh</i></td></tr>
          <tr><td valign="top" headers="matches"><tt>\t</tt></td>
            <td headers="matches">The tab character (<tt>'&#92;u0009'</tt>)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\n</tt></td>
            <td headers="matches">The newline (line feed) character (<tt>'&#92;u000A'</tt>)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\r</tt></td>
            <td headers="matches">The carriage-return character (<tt>'&#92;u000D'</tt>)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\f</tt></td>
            <td headers="matches">The form-feed character (<tt>'&#92;u000C'</tt>)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\a</tt></td>
            <td headers="matches">The alert (bell) character (<tt>'&#92;u0007'</tt>)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\e</tt></td>
            <td headers="matches">The escape character (<tt>'&#92;u001B'</tt>)</td></tr>
          <tr><td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td>
            <td headers="matches">The control character corresponding to <i>x</i></td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="classes">Character classes</th></tr>
          
          <tr><td valign="top" headers="construct classes"><tt>[abc]</tt></td>
            <td headers="matches"><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>
          <tr><td valign="top" headers="construct classes"><tt>[^abc]</tt></td>
            <td headers="matches">Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>
          <tr><td valign="top" headers="construct classes"><tt>[a-zA-Z]</tt></td>
            <td headers="matches"><tt>a</tt> through <tt>z</tt>
              or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>
          <tr><td valign="top" headers="construct classes"><tt>[a-d[m-p]]</tt></td>
            <td headers="matches"><tt>a</tt> through <tt>d</tt>,
              or <tt>m</tt> through <tt>p</tt>: <tt>[a-dm-p]</tt> (union)</td></tr>
          <tr><td valign="top" headers="construct classes"><tt>[a-z&&[def]]</tt></td>
            <td headers="matches"><tt>d</tt>, <tt>e</tt>, or <tt>f</tt> (intersection)</tr>
          <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^bc]]</tt></td>
            <td headers="matches"><tt>a</tt> through <tt>z</tt>,
              except for <tt>b</tt> and <tt>c</tt>: <tt>[ad-z]</tt> (subtraction)</td></tr>
          <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^m-p]]</tt></td>
            <td headers="matches"><tt>a</tt> through <tt>z</tt>,
              and not <tt>m</tt> through <tt>p</tt>: <tt>[a-lq-z]</tt>(subtraction)</td></tr>
          <tr><th>&nbsp;</th></tr>
          
          <tr align="left"><th colspan="2" id="predef">Predefined character classes</th></tr>
          
          <tr><td valign="top" headers="construct predef"><tt>.</tt></td>
            <td headers="matches">Any character (may or may not match <a href="#lt">line terminators</a>)</td></tr>
          <tr><td valign="top" headers="construct predef"><tt>\d</tt></td>
            <td headers="matches">A digit: <tt>[0-9]</tt></td></tr>
          <tr><td valign="top" headers="construct predef"><tt>\D</tt></td>
            <td headers="matches">A non-digit: <tt>[^0-9]</tt></td></tr>
          <tr><td valign="top" headers="construct predef"><tt>\s</tt></td>
            <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
          <tr><td valign="top" headers="construct predef"><tt>\S</tt></td>
            <td headers="matches">A non-whitespace character: <tt>[^\s]</tt></td></tr>
          <tr><td valign="top" headers="construct predef"><tt>\w</tt></td>
            <td headers="matches">A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
          <tr><td valign="top" headers="construct predef"><tt>\W</tt></td>
            <td headers="matches">A non-word character: <tt>[^\w]</tt></td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="posix">POSIX character classes<b> (US-ASCII only)</b></th></tr>
          
          <tr><td valign="top" headers="construct posix"><tt>\p{Lower}</tt></td>
            <td headers="matches">A lower-case alphabetic character: <tt>[a-z]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Upper}</tt></td>
            <td headers="matches">An upper-case alphabetic character:<tt>[A-Z]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{ASCII}</tt></td>
            <td headers="matches">All ASCII:<tt>[\x00-\x7F]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Alpha}</tt></td>
            <td headers="matches">An alphabetic character:<tt>[\p{Lower}\p{Upper}]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Digit}</tt></td>
            <td headers="matches">A decimal digit: <tt>[0-9]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Alnum}</tt></td>
            <td headers="matches">An alphanumeric character:<tt>[\p{Alpha}\p{Digit}]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Punct}</tt></td>
            <td headers="matches">Punctuation: One of <tt>!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</tt></td></tr>
          <!-- <tt>[\!"#\$%&'\(\)\*\+,\-\./:;\<=\>\?@\[\\\]\^_`\{\|\}~]</tt>
               <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> -->
          <tr><td valign="top" headers="construct posix"><tt>\p{Graph}</tt></td>
            <td headers="matches">A visible character: <tt>[\p{Alnum}\p{Punct}]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Print}</tt></td>
            <td headers="matches">A printable character: <tt>[\p{Graph}]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Blank}</tt></td>
            <td headers="matches">A space or a tab: <tt>[ \t]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Cntrl}</tt></td>
            <td headers="matches">A control character: <tt>[\x00-\x1F\x7F]</td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{XDigit}</tt></td>
            <td headers="matches">A hexadecimal digit: <tt>[0-9a-fA-F]</tt></td></tr>
          <tr><td valign="top" headers="construct posix"><tt>\p{Space}</tt></td>
            <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="unicode">Classes for Unicode blocks and categories</th></tr>
          
          <tr><td valign="top" headers="construct unicode"><tt>\p{InGreek}</tt></td>
            <td headers="matches">A character in the Greek&nbsp;block (simple <a href="#ubc">block</a>)</td></tr>
          <tr><td valign="top" headers="construct unicode"><tt>\p{Lu}</tt></td>
            <td headers="matches">An uppercase letter (simple <a href="#ubc">category</a>)</td></tr>
          <tr><td valign="top" headers="construct unicode"><tt>\p{Sc}</tt></td>
            <td headers="matches">A currency symbol</td></tr>
          <tr><td valign="top" headers="construct unicode"><tt>\P{InGreek}</tt></td>
            <td headers="matches">Any character except one in the Greek block (negation)</td></tr>
          <tr><td valign="top" headers="construct unicode"><tt>[\p{L}&&[^\p{Lu}]]&nbsp;</tt></td>
            <td headers="matches">Any letter except an uppercase letter (subtraction)</td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="bounds">Boundary matchers</th></tr>
          
          <tr><td valign="top" headers="construct bounds"><tt>^</tt></td>
            <td headers="matches">The beginning of a line</td></tr>
          <tr><td valign="top" headers="construct bounds"><tt>$</tt></td>
            <td headers="matches">The end of a line</td></tr>
          <tr><td valign="top" headers="construct bounds"><tt>\b</tt></td>
            <td headers="matches">A word boundary</td></tr>
          <tr><td valign="top" headers="construct bounds"><tt>\B</tt></td>
            <td headers="matches">A non-word boundary</td></tr>
          <tr><td valign="top" headers="construct bounds"><tt>\A</tt></td>
            <td headers="matches">The beginning of the input</td></tr>
          <tr><td valign="top" headers="construct bounds"><tt>\G</tt></td>
            <td headers="matches">The end of the previous match</td></tr>
          <tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td>
            <td headers="matches">The end of the input but for the final
              <a href="#lt">terminator</a>, if&nbsp;any</td></tr>
          <tr><td valign="top" headers="construct bounds"><tt>\z</tt></td>
            <td headers="matches">The end of the input</td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="greedy">Greedy quantifiers</th></tr>
          
          <tr><td valign="top" headers="construct greedy"><i>X</i><tt>?</tt></td>
            <td headers="matches"><i>X</i>, once or not at all</td></tr>
          <tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td>
            <td headers="matches"><i>X</i>, zero or more times</td></tr>
          <tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td>
            <td headers="matches"><i>X</i>, one or more times</td></tr>
          <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td>
            <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
          <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td>
            <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
          <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td>
            <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="reluc">Reluctant quantifiers</th></tr>
          
          <tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td>
            <td headers="matches"><i>X</i>, once or not at all</td></tr>
          <tr><td valign="top" headers="construct reluc"><i>X</i><tt>*?</tt></td>
            <td headers="matches"><i>X</i>, zero or more times</td></tr>
          <tr><td valign="top" headers="construct reluc"><i>X</i><tt>+?</tt></td>
            <td headers="matches"><i>X</i>, one or more times</td></tr>
          <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}?</tt></td>
            <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
          <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}?</tt></td>
            <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
          <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}?</tt></td>
            <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="poss">Possessive quantifiers</th></tr>
          
          <tr><td valign="top" headers="construct poss"><i>X</i><tt>?+</tt></td>
            <td headers="matches"><i>X</i>, once or not at all</td></tr>
          <tr><td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td>
            <td headers="matches"><i>X</i>, zero or more times</td></tr>
          <tr><td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td>
            <td headers="matches"><i>X</i>, one or more times</td></tr>
          <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td>
            <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
          <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td>
            <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
          <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td>
            <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="logical">Logical operators</th></tr>
          
          <tr><td valign="top" headers="construct logical"><i>XY</i></td>
            <td headers="matches"><i>X</i> followed by <i>Y</i></td></tr>
          <tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td>
            <td headers="matches">Either <i>X</i> or <i>Y</i></td></tr>
          <tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td>
            <td headers="matches">X, as a <a href="#cg">capturing group</a></td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="backref">Back references</th></tr>
          
          <tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td>
            <td valign="bottom" headers="matches">Whatever the <i>n</i><sup>th</sup>
              <a href="#cg">capturing group</a> matched</td></tr>
          
          <tr><th>&nbsp;</th></tr>
          <tr align="left"><th colspan="2" id="quot">Quotation</th></tr>
          
          <tr><td valign="top" headers="construct quot"><tt>\</tt></td>
            <td headers="matches">Nothing, but quotes the following character</td></tr>
          <tr><td valign="top" headers="construct quot"><tt>\Q</tt></td>
            <td headers="matches">Nothing, but quotes all characters until <tt>\E</tt></td></tr>
          <tr><td valign="top" headers="construct quot"><tt>\E</tt></td>
            <td headers="matches">Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
          <!-- Metachars: !$()*+.<>?[\]^{|} -->
            
            <tr><th>&nbsp;</th></tr>
            <tr align="left"><th colspan="2" id="special">Special constructs (non-capturing)</th></tr>
            
            <tr><td valign="top" headers="construct special"><tt>(?:</tt><i>X</i><tt>)</tt></td>
              <td headers="matches"><i>X</i>, as a non-capturing group</td></tr>
            <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux)&nbsp;</tt></td>
              <td headers="matches">Nothing, but turns match flags on - off</td></tr>
            <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td>
              <td headers="matches"><i>X</i>, as a <a href="#cg">non-capturing group</a> with the
                given flags on - off</td></tr>
            <tr><td valign="top" headers="construct special"><tt>(?=</tt><i>X</i><tt>)</tt></td>
              <td headers="matches"><i>X</i>, via zero-width positive lookahead</td></tr>
            <tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td>
              <td headers="matches"><i>X</i>, via zero-width negative lookahead</td></tr>
            <tr><td valign="top" headers="construct special"><tt>(?&lt;=</tt><i>X</i><tt>)</tt></td>
              <td headers="matches"><i>X</i>, via zero-width positive lookbehind</td></tr>
            <tr><td valign="top" headers="construct special"><tt>(?&lt;!</tt><i>X</i><tt>)</tt></td>
              <td headers="matches"><i>X</i>, via zero-width negative lookbehind</td></tr>
            <tr><td valign="top" headers="construct special"><tt>(?&gt;</tt><i>X</i><tt>)</tt></td>
              <td headers="matches"><i>X</i>, as an independent, non-capturing group</td></tr>
            
        </table>
        
        <hr>
        
        
        <a name="bs">
          <h4> Backslashes, escapes, and quoting </h4>
        </a>
        
        <p> The backslash character (<tt>'\'</tt>) serves to introduce escaped
          constructs, as defined in the table above, as well as to quote characters
          that otherwise would be interpreted as unescaped constructs.  Thus the
          expression <tt>\\</tt> matches a single backslash and <tt>\{</tt> matches a
          left brace.
          
        <p> It is an error to use a backslash prior to any alphabetic character that
          does not denote an escaped construct; these are reserved for future
          extensions to the regular-expression language.  A backslash may be used
          prior to a non-alphabetic character regardless of whether that character is
          part of an unescaped construct.
          
          <a name="cc">
            <h4> Character Classes </h4>
          </a>
          
        <p> Character classes may appear within other character classes, and
          may be composed by the union operator (implicit) and the intersection
          operator (<tt>&amp;&amp;</tt>).
          The union operator denotes a class that contains every character that is
          in at least one of its operand classes.  The intersection operator
          denotes a class that contains every character that is in both of its
          operand classes.
          
        <p> The precedence of character-class operators is as follows, from
          highest to lowest:
          
          <blockquote><table border="0" cellpadding="1" cellspacing="0" 
                             summary="Precedence of character class operators.">
              <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
	        <td>Literal escape&nbsp;&nbsp;&nbsp;&nbsp;</td>
	        <td><tt>\x</tt></td></tr>
              <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
	        <td>Grouping</td>
	        <td><tt>[...]</tt></td></tr>
              <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
	        <td>Range</td>
	        <td><tt>a-z</tt></td></tr>
              <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
	        <td>Union</td>
	        <td><tt>[a-e][i-u]<tt></td></tr>
              <tr><th>5&nbsp;&nbsp;&nbsp;&nbsp;</th>
	        <td>Intersection</td>
	        <td><tt>[a-z&&[aeiou]]</tt></td></tr>
          </table></blockquote>
          
        <p> Note that a different set of metacharacters are in effect inside
          a character class than outside a character class. For instance, the
          regular expression <tt>.</tt> loses its special meaning inside a
          character class, while the expression <tt>-</tt> becomes a range
          forming metacharacter.
          
          <a name="lt">
            <h4> Line terminators </h4>
          </a>
          
        <p> A <i>line terminator</i> is a one- or two-character sequence that marks
          the end of a line of the input character sequence.  The following are
          recognized as line terminators:
          
          <ul>
            
            <li> A newline (line feed) character&nbsp;(<tt>'\n'</tt>),
              
            <li> A carriage-return character followed immediately by a newline
              character&nbsp;(<tt>"\r\n"</tt>),
              
            <li> A standalone carriage-return character&nbsp;(<tt>'\r'</tt>),
              
            <li> A next-line character&nbsp;(<tt>'&#92;u0085'</tt>),
              
            <li> A line-separator character&nbsp;(<tt>'&#92;u2028'</tt>), or
              
            <li> A paragraph-separator character&nbsp;(<tt>'&#92;u2029</tt>).
              
          </ul>
          
          
        <p> By default, the regular expressions <tt>^</tt> and <tt>$</tt> ignore
          line terminators and only match at the beginning and the end, respectively,
          of the entire input sequence. 
          
          <a name="cg">
            <h4> Groups and capturing </h4>
          </a>
          
        <p> Capturing groups are numbered by counting their opening parentheses from
          left to right.  In the expression <tt>((A)(B(C)))</tt>, for example, there
          are four such groups: </p>
        
        <blockquote><table cellpadding=1 cellspacing=0 summary="Capturing group numberings">
            <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
              <td><tt>((A)(B(C)))</tt></td></tr>
            <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
              <td><tt>(A)</tt></td></tr>
            <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
              <td><tt>(B(C))</tt></td></tr>
            <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
              <td><tt>(C)</tt></td></tr>
        </table></blockquote>
        
        <p> Group zero always stands for the entire expression.
          
        <p> Capturing groups are so named because, during a match, each subsequence
          of the input sequence that matches such a group is saved.  The captured
          subsequence may be used later in the expression, via a back reference, and
          may also be retrieved from the matcher once the match operation is complete.
          
        <p> The captured input associated with a group is always the subsequence
          that the group most recently matched.  If a group is evaluated a second time
          because of quantification then its previously-captured value, if any, will
          be retained if the second evaluation fails.  Matching the string
          <tt>"aba"</tt> against the expression <tt>(a(b)?)+</tt>, for example, leaves
          group two set to <tt>"b"</tt>.  All captured input is discarded at the
          beginning of each match.
          
        <p> Groups beginning with <tt>(?</tt> are pure, <i>non-capturing</i> groups
          that do not capture text and do not count towards the group total.
          
          
          <h4> Unicode support </h4>
          
        <p> This class follows
          <a href="http://www.unicode.org/unicode/reports/tr18/"><i>Unicode Technical
              Report #18: Unicode Regular Expression Guidelines</i></a>, implementing its
          second level of support though with a slightly different concrete syntax.
          
        <p> Unicode escape sequences such as <tt>&#92;u2014</tt> in Java source code
          are processed as described in
          <a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#100850">?3.3</a>
          of the Java Language Specification.  Such escape sequences are also
          implemented directly by the regular-expression parser so that Unicode
          escapes can be used in expressions that are read from files or from the
          keyboard.  Thus the strings <tt>"&#92;u2014"</tt> and <tt>"\\u2014"</tt>,
          while not equal, compile into the same pattern, which matches the character
          with hexadecimal value <tt>0x2014</tt>.
          
        <p> <a name="ubc">Unicode blocks </a>
          and categories are written with the
          <tt>\p</tt> and <tt>\P</tt> constructs as in
          Perl. <tt>\p{</tt><i>prop</i><tt>}</tt> matches if the input has the
          property <i>prop</i>, while \P{</tt><i>prop</i><tt>}</tt> does not match if
          the input has that property.  Blocks are specified with the prefix
          <tt>In</tt>, as in <tt>InMongolian</tt>.  Categories may be specified with
          the optional prefix <tt>Is</tt>: Both <tt>\p{L}</tt> and <tt>\p{IsL}</tt>
          denote the category of Unicode letters.  Blocks and categories can be used
          both inside and outside of a character class.
          
        <p> The supported blocks and categories are those of
          <a href="http://www.unicode.org/unicode/standard/standard.html"><i>The Unicode
              Standard, Version&nbsp;3.0</i></a>.  The block names are those defined in
          Chapter&nbsp;14 and in the file
          <a chref="http://www.unicode.org/Public/3.0-Update/Blocks-3.txt">Blocks-3.txt
          </a> of the
          <a href="http://www.unicode.org/Public/3.0-Update/UnicodeCharacterDatabase-3.0.0.html">Unicode
            Character Database</a> except that the spaces are removed; <tt>"Basic
            Latin"</tt>, for example, becomes <tt>"BasicLatin"</tt>.  The category names
          are those defined in table 4-5 of the Standard (p.&nbsp;88), both normative
          and informative.
          
          
          <h4> Comparison to Perl 5 </h4>
          
        <p> Perl constructs not supported by this class: </p>
        
        <ul>
          
          <li><p> The conditional constructs <tt>(?{</tt><i>X</i><tt>})</tt> and
              <tt>(?(</tt><i>condition</i><tt>)</tt><i>X</i><tt>|</tt><i>Y</i><tt>)</tt>,
          </p></li>
          
          <li><p> The embedded code constructs <tt>(?{</tt><i>code</i><tt>})</tt>
              and <tt>(??{</tt><i>code</i><tt>})</tt>,</p></li>
          
          <li><p> The embedded comment syntax <tt>(?#comment)</tt>, and </p></li>
          
          <li><p> The preprocessing operations <tt>\l</tt> <tt>&#92;u</tt>,
              <tt>\L</tt>, and <tt>\U</tt>.  </p></li>
          
        </ul>
        
        <p> Constructs supported by this class but not by Perl: </p>
        
        <ul>
          
          <li><p> Possessive quantifiers, which greedily match as much as they can
              and do not back off, even when doing so would allow the overall match to
              succeed.  </p></li>
          
          <li><p> Character-class union and intersection as described
              <a href="#cc">above</a>.</p></li>
          
        </ul>    
      </details>
    </details>

    <hr>
    
    <form method="POST" action="setTaskParameters" id="form">
      <div class="field" title="Input layer from which words come">
        <label for="sourceLayerId">Source Layer</label>
        <span><select id="sourceLayerId" name="sourceLayerId" required></select></span>
      </div>
      
      <div class="field" title="Output layer on which new annotations are added">
        <label for="destinationLayerId">Destination Layer</label>
        <span>
          <select id="destinationLayerId" name="destinationLayerId" required>
            <option disabled>[select layer]</option> <!-- force choice the first time -->
            <option>[add new word layer]</option>    <!-- allow adding a new word layer -->
            <option>[add new phrase layer]</option>  <!-- allow adding a new turn layer -->
            <option>[add new span layer]</option>    <!-- allow adding a new graph layer -->
          </select>
          <input type="hidden" id="destinationLayerParentId" name="destinationLayerParentId">
        </span>
      </div>
      <div class="field language-field" title="Transcript attribute for overall language">
        <label for="transcriptLanguageLayerId">Transcript Language Attribute</label>
        <span>
          <select id="transcriptLanguageLayerId" name="transcriptLanguageLayerId">
            <option value="">[none]</option>
          </select>
        </span>
      </div>
      <div class="field language-field"
           title="Layer for annotating phrases in a different language">
        <label for="phraseLanguageLayerId">Phrase Language Layer</label>
        <span>
          <select id="phraseLanguageLayerId" name="phraseLanguageLayerId">
            <option value="">[none]</option>
          </select>
        </span>
      </div>
      <div class="field language-field"
           id="languageField"
           title="Regular expression for the ISO language codes of the languages to target, or blank for all">
        <label for="language">Language</label>
        <span><input id="language" name="language" type="text" placeholder="Language"></span>
      </div>
      
      <div id="mappingsDiv">
        <h3>Mappings</h3>
        <div id="mappings"></div>
        <div id="controls">
          <div id="add" style="display: table-row;">
	    <button id="addButton"
                    title="Add a pattern to match">
	      <img src="add.svg" alt="add" />
	    </button>
          </div>
          <div id="up" style="display: table-row;">
	    <button id="upButton"
                    title="Move selected pattern up (match it earlier)">
	      <img src="up.svg" alt="up" />
	    </button>
          </div>
          <div id="down" style="display: table-row;">
	    <button id="downButton" 
		    title="Move selected pattern down (match it later)">
	      <img src="down.svg" alt="down" />
	    </button>
          </div>
          <div id="remove" style="display: table-row;">
	    <button id="removeButton"
		    title="Remove selected pattern">
	      <img src="remove.svg" alt="remove" />
	    </button>
          </div>
        </div>
        <div id="nomapping"
             title="If the source layer annotation matches no pattern, then any pre-existing annotation in the target layer should be...">
          <select name="deleteOnNoMatch" id="deleteOnNoMatch">
	    <option value="true">Delete</option>
	    <option value="false">Ignore</option>
          </select> annotations in target layer whose source matches no pattern
        </div>
      </div><!-- mappingsDiv -->

      <div class="controls"><input type="submit" value="Set Parameters"></div>
    </form>
    
    <footer><div> Pattern Tagger <small id="version"></small> </div></footer>
    <script src="index.js" type="text/javascript"></script>
  </body>
</html>
